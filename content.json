{"meta":{"title":"追途的个人博客","subtitle":"herelookingatyoukid@gmail.com","description":"追途的个人博客","author":"追途","url":"http://hereislookingatyoukid.xyz","root":"/"},"pages":[{"title":"关于我","date":"2019-04-19T06:06:20.000Z","updated":"2019-04-19T06:16:38.747Z","comments":true,"path":"about/index.html","permalink":"http://hereislookingatyoukid.xyz/about/index.html","excerpt":"","text":"邮箱： herelookingatyoukid@gmail.com知行合一，止于至善。"}],"posts":[{"title":"Android杂项积累","slug":"Android杂项积累","date":"2019-05-20T10:55:54.000Z","updated":"2019-05-21T04:54:45.708Z","comments":true,"path":"2019/05/20/Android杂项积累/","link":"","permalink":"http://hereislookingatyoukid.xyz/2019/05/20/Android杂项积累/","excerpt":"","text":"1.DisplayMetrics相关 通过DisplayMetrics类可以获取尺寸相关设备信息，包括不限于宽高（像素为单位）、density（影响dp/dip）、scaledDensity（影响sp）。1.1 dp/dip(Density Independent Pixel)密度无关像素(Density Independent Pixel) 一种基于屏幕物理密度的抽象单元。 这些单位相对于160 dpi的屏幕，因此一个dp是160 dpi屏幕上的一个像素。 dp与像素的比率将随着屏幕密度而变化，但不一定成正比。 注意：编译器接受“dip”和“dp”，但“dp”与“sp”更一致。1.2 densitydensity是以160dpi为基准的，也就是160dpi屏幕对应的 density 是1。1.3 densityDpi用dpi(dots-per-inch)表示的屏幕密度。density 与 densityDpi 之间的换算关系density=denstyDpi/1601.4 dp/dip 与 pixel 的关系 dpdensity = pixel 例如：高为200dp的view在density为2.625的手机上绘制完成后获取到的view.getHeight()为525。 1.4 scaledDensity与字体相关的缩放密度。调整系统的字体大小会产生影响。1.5 sp与pixel的关系spscaledDensity = pixel相关手机参数： 手机型号 width height density denstyDpi scaledDensity MI MAX 1080 1920 2.75 440 2.75 一加5t 1080 2160 2.625 420 3.01875 通过计算得出的density MI MAX 与一加5t 分别为2.14 、2.51与获取值不一致，因为这些值厂商修改过。生产厂商生产出各式各样的Android设备，没有一个统一的规范，屏幕的density也就千差万别。 1.6 sdk自带的相关转换Utils TypeValue类下的： 123456789101112131415161718192021222324public static float applyDimension(int unit, float value, DisplayMetrics metrics)&#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; // dp2px case COMPLEX_UNIT_DIP: return value * metrics.density; // dp2sp case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; // dp2pt case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); // dp2in case COMPLEX_UNIT_IN: return value * metrics.xdpi; // dp2mm case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hereislookingatyoukid.xyz/tags/Android/"}]},{"title":"探究BitmapFactory.decodeResource","slug":"探究BitmapFactory-decodeResource","date":"2019-05-20T08:59:09.000Z","updated":"2019-05-20T09:20:05.915Z","comments":true,"path":"2019/05/20/探究BitmapFactory-decodeResource/","link":"","permalink":"http://hereislookingatyoukid.xyz/2019/05/20/探究BitmapFactory-decodeResource/","excerpt":"","text":"1.基础 关于静态类 BitmapFactory.Options inDensity : 当前bitmap的像素密度。inTargetDensity : 目标bitmap的像素密度。inScreenDensity : 屏幕的像素密度。 关于 TypedValue 类 主要被 android.content.res.Resources 类使用，动态的一中数据类型。 2.从 BitmapFactory.decodeResource 开始 调用静态方法 BitmapFactory.decodeResource ，加载诸如 /main/res/drawable-xxhdpi 文件夹下的资源 ，会间接调用 decodeResource(Resources res, int id, Options opts) 方法。 12345678910111213141516171819202122232425public static Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts) &#123; validate(opts); if (opts == null) &#123; // new出的opts的inDensity,inTargetDensity,inScreenDensity 都为 0 opts = new Options(); &#125; if (opts.inDensity == 0 &amp;&amp; value != null) &#123; // 通过value的值来修改density final int density = value.density; if (density == TypedValue.DENSITY_DEFAULT) &#123; opts.inDensity = DisplayMetrics.DENSITY_DEFAULT; &#125; else if (density != TypedValue.DENSITY_NONE) &#123; opts.inDensity = density; &#125; &#125; if (opts.inTargetDensity == 0 &amp;&amp; res != null) &#123; // 通过value的值来修改inTargetDensity opts.inTargetDensity = res.getDisplayMetrics().densityDpi; &#125; return decodeStream(is, pad, opts);&#125; 而后 调用 decodeStream 方法，跟进该方法 进入decodeStreamInternal 方法最后发现调用了nativeDecodeStream。 通过androidxref 检索到对应的native方法 。 1234567891011121314static jobject nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage, jobject padding, jobject options) &#123; jobject bitmap = NULL; std::unique_ptr&lt;SkStream&gt; stream(CreateJavaInputStreamAdaptor(env, is, storage)); if (stream.get()) &#123; std::unique_ptr&lt;SkStreamRewindable&gt; bufferedStream( SkFrontBufferedStream::Make(std::move(stream), SkCodec::MinBufferedBytesNeeded())); SkASSERT(bufferedStream.get() != NULL); bitmap = doDecode(env, std::move(bufferedStream), padding, options); &#125; return bitmap;&#125; 进入核心方法 doDecode 我们可以在 doDecode 方法中发现 最开始 Options 对象的三个字段 inDensity,inTargetDensity,inScreenDensity 直接作用于此，并对scale产生影响。 12345678if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123; const int density = env-&gt;GetIntField(options, gOptions_densityFieldID); const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID); const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123; scale = (float) targetDensity / density; &#125;&#125; 看到这三个字段最后作用于 doDecode 方法的 scale 大致也就能猜个七八。继续看 doDecode 方法之后对于 scale 的处理。 123456// Scale is necessary due to density differences.if (scale != 1.0f) &#123; willScale = true; scaledWidth = static_cast&lt;int&gt;(scaledWidth * scale + 0.5f); scaledHeight = static_cast&lt;int&gt;(scaledHeight * scale + 0.5f);&#125; scaledWidth 与 scaledHeight 后续作用于 outputBitmap 对象进而返回 bitmap。在通过BitmapFactory.decodeResource 获取 /res/drawable 中的内容 Options 的 三个字段会决定native中的scale值的大小，最后会影响图片的宽高导致加载到内存的大小也会有改变。scale关键赋值操作 123if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123; scale = (float) targetDensity / density; &#125; 3.demo测试 地址同一张图片（896*896）修改文件名放到 drawable-ldpi,drawable-hdpi,drwaable-xxhdpi,drawable-xxshdpi文件夹下，直接调用静态方法 BtmapFactory.ecodeResource(Resources res, int id) type getWidth() getHeight() getByteCount() drawable-ldpi 3285 3285 43164900 drawable-hdpi 1643 1643 10797796 drawable-xxhdpi 821 821 2696164 drawable-xxxhdpi 616 616 1517824 修改options 中影响 scale 的参数 inDensity 和 inTargetDensity（inScreenDensity仍为默认值） 1234 BitmapFactory.Options o = new BitmapFactory.Options(); o.inDensity = getResources().getDisplayMetrics().densityDpi; o.inTargetDensity = getResources().getDisplayMetrics().densityDpi;BitmapFactory.decodeResource(getResources(),R.drawable.pic_ldpi,o) type getWidth() getHeight() getByteCount() drawable-ldpi(change options) 896 896 3211264 总结：通过表一可知同一张图片放在不同 drawable-xxx 下会 影响图片的缩放，加载到内存中的大小会受到影响，直接影响着性能。通过表二可知动态的修改 options 参数可以调整你想要的 scale。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hereislookingatyoukid.xyz/tags/Android/"}]},{"title":"android 视图相关","slug":"android 视图相关","date":"2019-04-17T05:19:30.000Z","updated":"2019-04-19T06:02:21.079Z","comments":true,"path":"2019/04/17/android 视图相关/","link":"","permalink":"http://hereislookingatyoukid.xyz/2019/04/17/android 视图相关/","excerpt":"","text":"Android视图相关推荐3星：扔物线主站推荐4星：GcsSloop的自定义view教程推荐4星：Mastering the Android Touch System（这是我目前看过讲解最好的Android触摸反馈相关的视频） B站视频 Youtube源地址推荐5星：Mastering the Android Touch System 示例源码推荐5星：Mastering the Android Touch System PPT仿写酷界面 获奖作品1仿写酷界面 获奖作品2仿写酷界面 获奖作品3仿写酷界面 获奖作品4","categories":[{"name":"Android","slug":"Android","permalink":"http://hereislookingatyoukid.xyz/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://hereislookingatyoukid.xyz/tags/View/"}]}]}